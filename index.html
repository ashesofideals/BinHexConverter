<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>BIN â‡„ HEX Converter (Auto Reload + Memory)</title>
<style>
    body { font-family: sans-serif; padding: 20px; }
    .container { max-width: 600px; margin: 0 auto; }
    .btn-group { margin: 20px 0; }
    button { padding: 8px 16px; cursor: pointer; margin-right: 10px; }
    #fileName { color: #555; font-weight: bold; margin-left: 10px;}
    .info { font-size: 0.9em; color: #666; margin-top: 5px;}
</style>
</head>
<body>

<div class="container">
    <h2>BIN â‡„ Intel HEX Converter</h2>

    <div>
        <button onclick="openFile()">ğŸ“‚ choose your file</button>
        <span id="fileName">no file</span>
    </div>
    <div class="info" id="browserInfo">æ­£åœ¨æ£€æµ‹æµè§ˆå™¨æ”¯æŒæƒ…å†µ...</div>

    <br>
    BIN2HEX OFFSET(HEX):
    <input id="baseAddr" value="00000000">
    <br><br>

    <div class="btn-group">
        <button onclick="binToHex()">BIN â†’ HEX</button>
        <button onclick="hexToBin()">HEX â†’ BIN</button>
    </div>
</div>

<script>
let fileHandle = null;
const APP_ID = 'hex-converter-v1-work-dir'; // å”¯ä¸€çš„IDï¼Œç”¨äºè®°å¿†æ–‡ä»¶å¤¹

// ================= IndexedDB è¾…åŠ©å‡½æ•° =================
const DB_NAME = 'HexBinToolDB';
const DB_VERSION = 1;
const STORE_NAME = 'fileHandles';

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function saveHandle(handle) {
    try {
        const db = await initDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).put(handle, 'lastFile');
        console.log("æ–‡ä»¶å¥æŸ„å·²ä¿å­˜");
    } catch (e) { console.error("ä¿å­˜æ–‡ä»¶å¥æŸ„å¤±è´¥", e); }
}

async function loadHandle() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const req = tx.objectStore(STORE_NAME).get('lastFile');
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    } catch (e) { return null; }
}

// ================= é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ¢å¤æ–‡ä»¶ =================
window.addEventListener('load', async () => {
    const infoEl = document.getElementById('browserInfo');

    if (!window.showOpenFilePicker) {
        infoEl.innerText = "âš ï¸ å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ File System Access APIï¼Œæ— æ³•ä½¿ç”¨è‡ªåŠ¨é‡è½½åŠŸèƒ½ã€‚";
        infoEl.style.color = "red";
        return;
    }

    // ç®€å•çš„ç‰ˆæœ¬æ£€æµ‹æç¤ºï¼ˆChrome 102+ æ”¯æŒ id å±æ€§ï¼‰
    const userAgent = navigator.userAgent;
    const chromeMatch = userAgent.match(/Chrome\/(\d+)/);
    if (chromeMatch) {
        const version = parseInt(chromeMatch[1], 10);
        if (version < 102) {
            infoEl.innerHTML = `âš ï¸ Chrome ç‰ˆæœ¬è¾ƒä½ (${v})ï¼Œè®°å¿†æ–‡ä»¶å¤¹åŠŸèƒ½éœ€è¦ Chrome 102+ã€‚`;
        } else {
            infoEl.innerText = "âœ… æµè§ˆå™¨æ”¯æŒè®°å¿†æ–‡ä»¶å¤¹ä¸è‡ªåŠ¨é‡è½½";
        }
    }

    // å°è¯•æ¢å¤ä¸Šæ¬¡æ–‡ä»¶
    const savedHandle = await loadHandle();
    if (savedHandle) {
        // æ£€æŸ¥æƒé™æ˜¯å¦å·²æˆäºˆ
        let permission = await savedHandle.queryPermission({ mode: 'read' });

        if (permission === 'granted') {
            fileHandle = savedHandle;
            document.getElementById("fileName").innerText = "å·²è‡ªåŠ¨æ¢å¤: " + fileHandle.name;
            console.log("è‡ªåŠ¨æ¢å¤æ–‡ä»¶å¥æŸ„:", fileHandle.name);
        } else if (permission === 'prompt') {
            // æ³¨æ„ï¼šç”±äº load äº‹ä»¶ä¸æ˜¯ç”¨æˆ·æ‰‹åŠ¿ï¼ŒrequestPermission åœ¨æŸäº›æµè§ˆå™¨å¯èƒ½ä¼šæŠ¥é”™æˆ–è¢«æ‹¦æˆª
            // è¿™é‡Œå°è¯•è¯·æ±‚ï¼Œå¦‚æœå¤±è´¥åˆ™ä¸åšå¤„ç†ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»â€œé€‰æ‹©æ–‡ä»¶â€
            try {
                permission = await savedHandle.requestPermission({ mode: 'read' });
                if (permission === 'granted') {
                    fileHandle = savedHandle;
                    document.getElementById("fileName").innerText = "å·²è‡ªåŠ¨æ¢å¤: " + fileHandle.name;
                }
            } catch (e) {
                console.log("æ— æ³•åœ¨é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¯·æ±‚æƒé™ï¼Œéœ€æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶ã€‚");
            }
        }
    }
});

// ================= æ–‡ä»¶é€‰æ‹©é€»è¾‘ =================
async function openFile() {
    if (!window.showOpenFilePicker) {
        alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ File System Access APIã€‚\nè¯·ä½¿ç”¨æœ€æ–°ç‰ˆ Chrome æˆ– Edgeã€‚");
        return;
    }

    try {
        // é…ç½®é€‰é¡¹
        const options = {
            id: APP_ID, // å…³é”®ï¼šé€šè¿‡ ID è®°å¿†ç›®å½•
            multiple: false,
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ  types è¿‡æ»¤å™¨ï¼Œä¾‹å¦‚:
            // types: [{
            //   description: 'Binary/Hex Files',
            //   accept: { 'application/octet-stream': ['.bin', '.hex'] }
            // }]
        };

        [fileHandle] = await window.showOpenFilePicker(options);

        // ä¿å­˜åˆ° IndexedDBï¼Œä¸‹æ¬¡åˆ·æ–°é¡µé¢èƒ½è‡ªåŠ¨åŠ è½½
        await saveHandle(fileHandle);

        document.getElementById("fileName").innerText = "å·²é€‰æ‹©: " + fileHandle.name;
        console.log("æ–‡ä»¶å¥æŸ„å·²è·å–å¹¶ä¿å­˜:", fileHandle.name);
    } catch (err) {
        if (err.name !== 'AbortError') {
            console.error("æ‰“å¼€æ–‡ä»¶é”™è¯¯:", err);
            alert("æ‰“å¼€æ–‡ä»¶å¤±è´¥: " + err.message);
        }
    }
}

// ================= BIN -> HEX =================
async function binToHex() {
    if (!fileHandle) {
        alert("è¯·å…ˆç‚¹å‡»â€œé€‰æ‹©æ–‡ä»¶â€æŒ‰é’®");
        return;
    }

    try {
        const file = await fileHandle.getFile();
        const buffer = await file.arrayBuffer();
        let data = new Uint8Array(buffer);

        console.log(`è¯»å–æ–‡ä»¶: ${file.name} (ä¿®æ”¹æ—¶é—´: ${new Date(file.lastModified).toLocaleTimeString()})`);

        const lineSize = 16;
        let tailByte = null;
        let tailCount = 0;
        for (let i = data.length - 1; i >= 0; i--) {
            const b = data[i];
            if (b === 0xFF || b === 0x00) {
                if (tailByte === null) tailByte = b;
                if (b === tailByte) tailCount++;
                else break;
            } else break;
        }
        if (tailCount >= lineSize) {
            const linesToRemove = Math.floor(tailCount / lineSize);
            data = data.slice(0, data.length - linesToRemove * lineSize);
            console.log(`è£å‰ªå°¾éƒ¨ ${linesToRemove * lineSize} ä¸ªå­—èŠ‚ (${linesToRemove} è¡Œ)`);
        }

        const hex = makeIntelHex(data);
        download(hex, "output.hex", "text/plain");
    } catch (err) {
        alert("è¯»å–æ–‡ä»¶å¤±è´¥: " + err.message);
    }
}

function makeIntelHex(data) {
    const lineSize = 16;
    let baseAddr = parseInt(document.getElementById("baseAddr").value || "0", 16) >>> 0;
    let addr = baseAddr & 0xFFFF;
    let high = baseAddr >>> 16;
    let out = "";

    out += makeExtAddrRecord(high);

    for (let i = 0; i < data.length; i += lineSize) {
        if (addr + lineSize > 0x10000) {
            high++;
            addr = 0;
            out += makeExtAddrRecord(high);
        }
        const chunk = data.slice(i, i + lineSize);
        const len = chunk.length;
        let sum = len + (addr >> 8) + (addr & 0xFF);
        let line = ":" + toHex(len,2) + toHex(addr,4) + "00";
        chunk.forEach(b => { line += toHex(b,2); sum += b; });
        const checksum = ((~sum + 1) & 0xFF);
        line += toHex(checksum,2);
        out += line + "\n";
        addr += len;
    }
    out += ":00000001FF\n";
    return out;
}

function makeExtAddrRecord(high16) {
    const b1 = (high16 >> 8) & 0xFF;
    const b2 = high16 & 0xFF;
    const sum = 2 + 0 + 0 + 4 + b1 + b2;
    const checksum = ((~sum + 1) & 0xFF);
    return ":02000004" + toHex(b1,2) + toHex(b2,2) + toHex(checksum,2) + "\n";
}

// ================= HEX -> BIN =================
async function hexToBin() {
    if (!fileHandle) {
        alert("è¯·å…ˆç‚¹å‡»â€œé€‰æ‹©æ–‡ä»¶â€æŒ‰é’®");
        return;
    }

    try {
        const file = await fileHandle.getFile();
        const text = await file.text();
        console.log(`è¯»å–HEXæ–‡ä»¶ (ä¿®æ”¹æ—¶é—´: ${new Date(file.lastModified).toLocaleTimeString()})`);

        const bin = parseIntelHex(text);
        if (!bin || bin.length === 0) {
            console.log("HEX æ–‡ä»¶è§£æå¤±è´¥æˆ–æ ¡éªŒå¤±è´¥ï¼Œæœªç”Ÿæˆ BIN æ–‡ä»¶");
            return;
        }
        download(bin, "output.bin", "application/octet-stream");
    } catch (err) {
        alert("è¯»å–æ–‡ä»¶å¤±è´¥: " + err.message);
    }
}

function parseIntelHex(text) {
    const lines = text.trim().split(/\r?\n/);
    let extAddr = 0;
    let mem = new Map();
    let minAddr = Number.MAX_SAFE_INTEGER;
    let maxAddr = 0;

    for (let lineNo = 0; lineNo < lines.length; lineNo++) {
        const line = lines[lineNo].trim();
        if (!line) continue;
        if (line[0] !== ":") {
            alert(`ç¬¬ ${lineNo+1} è¡Œæ ¼å¼é”™è¯¯ï¼ˆç¼ºå°‘å†’å·ï¼‰`);
            return null;
        }

        const len  = parseInt(line.substr(1,2),16);
        const addr = parseInt(line.substr(3,4),16);
        const type = parseInt(line.substr(7,2),16);
        const dataStart = 9;
        const dataEnd   = dataStart + len * 2;
        const checksum  = parseInt(line.substr(dataEnd,2),16);

        let sum = 0;
        for (let i = 1; i < dataEnd; i += 2) sum += parseInt(line.substr(i,2),16);
        sum &= 0xFF;
        const calc = ((~sum + 1) & 0xFF);

        if (calc !== checksum) {
            alert(
                `HEXæ ¡éªŒå¤±è´¥!\n` +
                `è¡Œå·: ${lineNo+1}\n` +
                `æœŸæœ›: 0x${checksum.toString(16)}\n` +
                `è®¡ç®—: 0x${calc.toString(16)}`
            );
            return null;
        }

        if (type === 0x00) {
            const base = (extAddr << 16) | addr;
            for (let i = 0; i < len; i++) {
                const val = parseInt(line.substr(dataStart + i*2,2),16);
                const abs = base + i;
                mem.set(abs, val);
                if (abs < minAddr) minAddr = abs;
                if (abs > maxAddr) maxAddr = abs;
            }
        } else if (type === 0x04) {
            extAddr = parseInt(line.substr(9,4),16);
        } else if (type === 0x01) break;
    }

    if (mem.size === 0) {
        alert("HEXæ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆæ•°æ®è®°å½•");
        return null;
    }

    const fill = 0xFF;
    const size = maxAddr - minAddr + 1;
    const out  = new Uint8Array(size);
    out.fill(fill);
    for (const [addr, val] of mem) out[addr - minAddr] = val;

    console.log(
        "HEXè§£æå®Œæˆ:", "0x" + minAddr.toString(16),
        "~", "0x" + maxAddr.toString(16),
        "Size:", size
    );
    return out;
}

function toHex(v, n) { return v.toString(16).toUpperCase().padStart(n,'0'); }

function download(data, filename, type) {
    const blob = data instanceof Uint8Array ? new Blob([data], {type}) : new Blob([data], {type});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}
</script>

</body>
</html>
